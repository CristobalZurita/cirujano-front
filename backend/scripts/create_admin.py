#!/usr/bin/env python3
"""Create a local admin user for development/testing.

Usage: python backend/scripts/create_admin.py --email admin@example.com --username admin --password secret
"""
import os
import sys
import argparse

# Ensure backend package imports work when run from repository root
HERE = os.path.dirname(os.path.dirname(__file__))
if HERE not in sys.path:
    sys.path.insert(0, HERE)
ROOT = os.path.dirname(HERE)
if ROOT not in sys.path:
    sys.path.insert(0, ROOT)

import sqlite3
from datetime import datetime
from typing import Optional
from passlib.context import CryptContext

# Simple sqlite-based admin creation (avoids importing ORM which can conflict in scripts)
def find_db_path(explicit: Optional[str] = None) -> str:
    """Find the most appropriate cirujano.db file to operate on.

    Search order:
    1. explicit path passed by CLI or environment (DB_PATH)
    2. backend/cirujano.db
    3. repository-root cirujano.db (often generated by the DB generator)
    If a candidate contains a `users` table it is selected immediately.
    Otherwise fall back to backend/cirujano.db path.
    """
    candidates = []
    if explicit:
        candidates.append(explicit)
    env_path = os.getenv('DB_PATH')
    if env_path:
        candidates.append(env_path)

    candidates.extend([
        os.path.join(HERE, 'cirujano.db'),
        os.path.join(ROOT, 'cirujano.db'),
    ])

    for p in candidates:
        try:
            if not p or not os.path.exists(p):
                continue
            conn = sqlite3.connect(p)
            cur = conn.cursor()
            cur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='users' LIMIT 1;")
            if cur.fetchone():
                conn.close()
                return p
            conn.close()
        except Exception:
            continue

    # Default fallback: backend/cirujano.db (may be created later)
    return os.path.join(HERE, 'cirujano.db')


# default used when not specified; resolved at runtime via find_db_path()
DB_PATH = None
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


def hash_password(password: str) -> str:
    try:
        return pwd_context.hash(password)
    except Exception:
        # Fallback: some environments have broken bcrypt builds; use pbkdf2_sha256 instead
        try:
            from passlib.hash import pbkdf2_sha256
            return pbkdf2_sha256.hash(password)
        except Exception:
            # As last resort, return the plain password (not ideal) but print a warning
            print("Warning: password hashing failed, storing plain password (development only)")
            return password


def create_admin(email, username, password, db_path: Optional[str] = None):
    db = db_path or find_db_path()
    conn = sqlite3.connect(db)
    try:
        cur = conn.cursor()
        cur.execute("SELECT id, email FROM users WHERE email = ?", (email,))
        if cur.fetchone():
            print(f"Admin user already exists: {email}")
            return

        hashed = hash_password(password)
        now = datetime.utcnow().isoformat()
        cur.execute(
            "INSERT INTO users (email, username, full_name, hashed_password, phone, role, is_active, created_at, updated_at) VALUES (?,?,?,?,?,?,?,?,?)",
            (email, username, 'Admin User', hashed, None, 'admin', 1, now, now)
        )
        conn.commit()
        print(f"Created admin user {email} / {username}")
    finally:
        conn.close()


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--email', required=True)
    parser.add_argument('--username', required=True)
    parser.add_argument('--password', required=True)
    parser.add_argument('--db-path', required=False, help='Path to sqlite db file to use')
    args = parser.parse_args()
    create_admin(args.email, args.username, args.password, db_path=args.db_path)
