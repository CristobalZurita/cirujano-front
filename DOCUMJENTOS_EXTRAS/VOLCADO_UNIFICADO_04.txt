###############################################
# VOLCADO_UNIFICADO_04.txt
# Tue Jan  6 18:31:44 -03 2026
# Proyecto: cirujano-front
###############################################

================ TREE ESTRUCTURAL ================
src
├── assets
│   └── data
│       ├── VIEJOS
│       │   ├── brands.json
│       │   ├── faults.json
│       │   └── instruments.json
│       ├── brands.json
│       ├── faults.json
│       └── instruments.json
├── composables
│   ├── emails.js
│   ├── layout.js
│   ├── scheduler.js
│   ├── settings.js
│   ├── strings.js
│   ├── useApi.js
│   ├── useAuth.js
│   ├── useCategories.js
│   ├── useDiagnostic.js
│   ├── useDiagnostics.js
│   ├── useInstruments.js
│   ├── useInstrumentsCatalog.js
│   ├── useInventory.js
│   ├── useRepairs.js
│   ├── useStockMovements.js
│   ├── useUsers.js
│   └── utils.js
├── main.js
├── models
│   └── SectionInfo.js
├── router
│   └── index.js
├── scss
│   ├── _brand.scss
│   ├── _layout.scss
│   ├── _mixins.scss
│   ├── _theming.scss
│   ├── _typography.scss
│   ├── _variables.scss
│   └── style.scss
├── stores
│   ├── auth.js
│   ├── categories.js
│   ├── diagnostics.js
│   ├── instruments.js
│   ├── inventory.js
│   ├── repairs.js
│   ├── stockMovements.js
│   └── users.js
└── vue
    ├── components
    │   ├── admin
    │   │   ├── CategoryForm.vue
    │   │   ├── CategoryList.vue
    │   │   ├── CategoryManager.vue
    │   │   ├── ClientDetail.vue
    │   │   ├── ClientList.vue
    │   │   ├── DiagnosticsList.vue
    │   │   ├── InstrumentForm.vue
    │   │   ├── InstrumentList.vue
    │   │   ├── InventoryAlerts.vue
    │   │   ├── InventoryForm.vue
    │   │   ├── InventoryTable.vue
    │   │   ├── RepairForm.vue
    │   │   ├── RepairManager.vue
    │   │   ├── RepairStatusEditor.vue
    │   │   ├── RepairsList.vue
    │   │   ├── StatsCards.vue
    │   │   ├── StockMovements.vue
    │   │   ├── StockMovementsList.vue
    │   │   ├── UserForm.vue
    │   │   └── UserList.vue
    │   ├── ai
    │   │   ├── AIAnalysisResult.vue
    │   │   ├── FaultDetector.vue
    │   │   ├── FaultMarker.vue
    │   │   ├── ImageUploader.vue
    │   │   └── QuoteGenerator.vue
    │   ├── articles
    │   │   ├── ArticleCustomContent.vue
    │   │   ├── ArticleFaq.vue
    │   │   ├── ArticleFeatures.vue
    │   │   ├── ArticleInfoBlock.vue
    │   │   ├── ArticleParagraph.vue
    │   │   ├── ArticleProjectGrid.vue
    │   │   ├── ArticleQuotes.vue
    │   │   ├── ArticleTestimonials.vue
    │   │   ├── ArticleTimeline.vue
    │   │   ├── DiagnosticWizard.vue
    │   │   └── items
    │   │       ├── ItemFaqQuestion.vue
    │   │       ├── ItemFeature.vue
    │   │       ├── ItemProjectGrid.vue
    │   │       ├── ItemQuote.vue
    │   │       ├── ItemTestimonial.vue
    │   │       └── ItemTimelineEntry.vue
    │   ├── auth
    │   │   ├── AccountDelete.vue
    │   │   ├── LoginForm.vue
    │   │   ├── PasswordReset.vue
    │   │   └── RegisterForm.vue
    │   ├── dashboard
    │   │   ├── DashboardPanel.vue
    │   │   ├── QuickStats.vue
    │   │   ├── RepairCard.vue
    │   │   ├── RepairTimeline.vue
    │   │   ├── RepairsList.vue
    │   │   ├── StatusBadge.vue
    │   │   └── UserProfile.vue
    │   ├── footer
    │   │   ├── Footer.vue
    │   │   ├── FooterBlock.vue
    │   │   ├── FooterColumn.vue
    │   │   └── FooterCopyright.vue
    │   ├── forms
    │   │   └── contact
    │   │       ├── ContactForm.vue
    │   │       ├── ContactFormFields.vue
    │   │       └── ContactFormSuccess.vue
    │   ├── generic
    │   │   ├── ImageView.vue
    │   │   └── Link.vue
    │   ├── layout
    │   │   ├── BackgroundPromo.vue
    │   │   ├── PageHeader.vue
    │   │   ├── PageSection.vue
    │   │   ├── PageSectionContent.vue
    │   │   ├── PageSectionFooter.vue
    │   │   ├── PageSectionHeader.vue
    │   │   └── PageWrapper.vue
    │   ├── loaders
    │   │   ├── ActivitySpinner.vue
    │   │   └── Loader.vue
    │   ├── nav
    │   │   ├── Navigation.vue
    │   │   ├── navbar
    │   │   │   ├── Navbar.vue
    │   │   │   ├── NavbarBrand.vue
    │   │   │   ├── NavbarLinks.vue
    │   │   │   └── NavbarToggleButton.vue
    │   │   └── navbar-wrappers
    │   │       ├── InPageNavbar.vue
    │   │       └── RouteNavbar.vue
    │   ├── projects
    │   │   ├── ProjectInfo.vue
    │   │   ├── ProjectInfoContent.vue
    │   │   ├── ProjectInfoFeaturedContent.vue
    │   │   └── ProjectModal.vue
    │   └── widgets
    │       ├── Alert.vue
    │       ├── Breadcrumbs.vue
    │       ├── CircleIcon.vue
    │       ├── Divider.vue
    │       ├── FilterTabs.vue
    │       ├── FloatingQuoteButton.vue
    │       ├── InlineLinkList.vue
    │       ├── ProgressBar.vue
    │       ├── QuotedText.vue
    │       ├── SocialLinks.vue
    │       ├── Spinner.vue
    │       └── XLButton.vue
    ├── content
    │   ├── Master.vue
    │   ├── pages
    │   │   ├── CotizadorIAPage.vue
    │   │   ├── DashboardPage.vue
    │   │   ├── HomePage.vue
    │   │   ├── LicensePage.vue
    │   │   ├── LoginPage.vue
    │   │   ├── PolicyPage.vue
    │   │   ├── ProfilePage.vue
    │   │   ├── RegisterPage.vue
    │   │   ├── RepairsPage.vue
    │   │   └── admin
    │   │       ├── AdminDashboard.vue
    │   │       ├── CategoriesPage.vue
    │   │       ├── ClientsPage.vue
    │   │       ├── InventoryPage.vue
    │   │       ├── RepairsAdminPage.vue
    │   │       └── StatsPage.vue
    │   └── sections
    │       ├── AboutSection.vue
    │       ├── ContactSection.vue
    │       ├── FaqSection.vue
    │       ├── FeaturedProjectSection.vue
    │       ├── HeroSection.vue
    │       ├── HistorySection.vue
    │       ├── LicenseSection.vue
    │       ├── PolicySection.vue
    │       ├── PortfolioSection.vue
    │       ├── ReviewsSection.vue
    │       ├── ServicesSection.vue
    │       └── TeamSection.vue
    ├── sections
    │   └── DiagnosticSection.vue
    └── stack
        ├── App.vue
        ├── ContentLayer.vue
        ├── FeedbacksLayer.vue
        └── StateProviderLayer.vue
backend
├── app
│   ├── __init__.py
│   ├── api
│   │   ├── __init__.py
│   │   └── v1
│   │       ├── __init__.py
│   │       ├── endpoints
│   │       │   ├── ai.py
│   │       │   ├── auth.py
│   │       │   ├── brands.py
│   │       │   ├── categories.py
│   │       │   ├── diagnostics.py
│   │       │   ├── instruments.py
│   │       │   ├── inventory.py
│   │       │   ├── repairs.py
│   │       │   ├── stats.py
│   │       │   └── users.py
│   │       └── router.py
│   ├── core
│   │   ├── __init__.py
│   │   ├── config.py
│   │   ├── database.py
│   │   ├── dependencies.py
│   │   ├── logging_config.py
│   │   ├── ratelimit.py
│   │   └── security.py
│   ├── crud
│   │   ├── __init__.py
│   │   ├── base.py
│   │   ├── category.py
│   │   ├── inventory.py
│   │   ├── repair.py
│   │   └── user.py
│   ├── main.py
│   ├── models
│   │   ├── __init__.py
│   │   ├── audit.py
│   │   ├── brand.py
│   │   ├── category.py
│   │   ├── diagnostic.py
│   │   ├── instrument.py
│   │   ├── inventory.py
│   │   ├── payment.py
│   │   ├── repair.py
│   │   ├── stock_movement.py
│   │   └── user.py
│   ├── routers
│   │   ├── __init__.py
│   │   ├── category.py
│   │   ├── contact.py
│   │   ├── diagnostic.py
│   │   ├── instrument.py
│   │   ├── payments.py
│   │   ├── repair.py
│   │   ├── stock_movement.py
│   │   ├── uploads.py
│   │   └── user.py
│   ├── schemas
│   │   ├── __init__.py
│   │   ├── auth.py
│   │   ├── category.py
│   │   ├── diagnostic.py
│   │   ├── inventory.py
│   │   ├── repair.py
│   │   └── user.py
│   ├── schemas.py
│   ├── services
│   │   ├── ai_detector.py
│   │   ├── email_service.py
│   │   ├── image_analysis.py
│   │   ├── logging_service.py
│   │   ├── pdf_generator.py
│   │   └── quote_calculator.py
│   └── utils
│       └── uploads.py
├── cirujano.db
└── tests
    ├── __init__.py
    ├── conftest.py
    ├── test_audit_hooks.py
    ├── test_audit_logging.py
    ├── test_config.py
    ├── test_payments_concurrency.py
    ├── test_payments_endpoints.py
    ├── test_ratelimit.py
    └── test_uploads.py
public
├── fonts
│   ├── CERVO
│   │   ├── CervoNeueCon-Black.otf
│   │   ├── CervoNeueCon-Black.ttf
│   │   ├── CervoNeueCon-Black.woff
│   │   ├── CervoNeueCon-Black.woff2
│   │   ├── CervoNeueCon-BlackItalic.otf
│   │   ├── CervoNeueCon-BlackItalic.ttf
│   │   ├── CervoNeueCon-BlackItalic.woff
│   │   ├── CervoNeueCon-BlackItalic.woff2
│   │   ├── CervoNeueCon-Medium.otf
│   │   ├── CervoNeueCon-Medium.ttf
│   │   ├── CervoNeueCon-Medium.woff
│   │   ├── CervoNeueCon-Medium.woff2
│   │   ├── CervoNeueCon-MediumItalic.otf
│   │   ├── CervoNeueCon-MediumItalic.ttf
│   │   ├── CervoNeueCon-MediumItalic.woff
│   │   ├── CervoNeueCon-MediumItalic.woff2
│   │   ├── CervoNeueCon-Regular.otf
│   │   ├── CervoNeueCon-Regular.ttf
│   │   ├── CervoNeueCon-Regular.woff
│   │   ├── CervoNeueCon-Regular.woff2
│   │   ├── CervoNeueCon-RegularItalic.otf
│   │   ├── CervoNeueCon-RegularItalic.ttf
│   │   ├── CervoNeueCon-RegularItalic.woff
│   │   ├── CervoNeueCon-RegularItalic.woff2
│   │   ├── CervoNeueCon-SemiBold.otf
│   │   ├── CervoNeueCon-SemiBold.ttf
│   │   ├── CervoNeueCon-SemiBold.woff
│   │   ├── CervoNeueCon-SemiBold.woff2
│   │   ├── CervoNeueCon-SemiBoldItalic.otf
│   │   ├── CervoNeueCon-SemiBoldItalic.ttf
│   │   ├── CervoNeueCon-SemiBoldItalic.woff
│   │   ├── CervoNeueCon-SemiBoldItalic.woff2
│   │   ├── CervoNeueCon-Thin.otf
│   │   ├── CervoNeueCon-Thin.ttf
│   │   ├── CervoNeueCon-Thin.woff
│   │   ├── CervoNeueCon-Thin.woff2
│   │   ├── CervoNeueCon-ThinItalic.otf
│   │   ├── CervoNeueCon-ThinItalic.ttf
│   │   ├── CervoNeueCon-ThinItalic.woff
│   │   ├── CervoNeueCon-ThinItalic.woff2
│   │   ├── CervoNeueCon-XtrBold.otf
│   │   ├── CervoNeueCon-XtrBold.ttf
│   │   ├── CervoNeueCon-XtrBold.woff
│   │   ├── CervoNeueCon-XtrBold.woff2
│   │   ├── CervoNeueCon-XtrBoldItalic.otf
│   │   ├── CervoNeueCon-XtrBoldItalic.ttf
│   │   ├── CervoNeueCon-XtrBoldItalic.woff
│   │   ├── CervoNeueCon-XtrBoldItalic.woff2
│   │   ├── CervoNeueCon-XtrLight.otf
│   │   ├── CervoNeueCon-XtrLight.ttf
│   │   ├── CervoNeueCon-XtrLight.woff
│   │   ├── CervoNeueCon-XtrLight.woff2
│   │   ├── CervoNeueCon-XtrLightItalic.otf
│   │   ├── CervoNeueCon-XtrLightItalic.ttf
│   │   ├── CervoNeueCon-XtrLightItalic.woff
│   │   └── CervoNeueCon-XtrLightItalic.woff2
│   ├── steelfish rg.otf
│   ├── steelfish rg.ttf
│   ├── steelfish rg.woff
│   └── steelfish rg.woff2
└── images
    ├── avatars
    ├── clients
    ├── history
    ├── instrumentos
    ├── logo
    └── portfolio

57 directories, 301 files

================ FRONTEND CORE ==================

----- FILE: src/composables/useApi.js -----
/**
 * Composable useApi.js - Cliente HTTP para API
 * 
 * Proporciona un cliente Axios configurado con:
 * - Base URL
 * - Autenticación automática
 * - Manejo de errores
 * - Refresh token automático
 */

import axios from 'axios'
import { useAuth } from './useAuth'

const API_URL = 'http://localhost:8000/api/v1'

// Instancia de axios
const api = axios.create({
  baseURL: API_URL,
  headers: {
    'Content-Type': 'application/json'
  }
})

// Interceptor para agregar token en requests
api.interceptors.request.use(
  (config) => {
    const { token } = useAuth()
    if (token.value) {
      config.headers.Authorization = `Bearer ${token.value}`
    }
    return config
  },
  (error) => Promise.reject(error)
)

// Interceptor para manejar respuestas y refresh token
api.interceptors.response.use(
  (response) => response,
  async (error) => {
    const { token, refreshAccessToken, logout } = useAuth()
    const originalRequest = error.config

    // Si es error 401 y aún no hemos reintentado
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true

      try {
        // Intentar refrescar token
        await refreshAccessToken()
        
        // Reintentar request original con nuevo token
        return api(originalRequest)
      } catch (refreshError) {
        // Si refresh falla, logout
        logout()
        return Promise.reject(refreshError)
      }
    }

    return Promise.reject(error)
  }
)

export function useApi() {
  /**
   * GET request
   */
  async function get(url, config = {}) {
    try {
      const response = await api.get(url, config)
      return response.data
    } catch (error) {
      throw handleError(error)
    }
  }

  /**
   * POST request
   */
  async function post(url, data = {}, config = {}) {
    try {
      const response = await api.post(url, data, config)
      return response.data
    } catch (error) {
      throw handleError(error)
    }
  }

  /**
   * PUT request
   */
  async function put(url, data = {}, config = {}) {
    try {
      const response = await api.put(url, data, config)
      return response.data
    } catch (error) {
      throw handleError(error)
    }
  }

  /**
   * PATCH request
   */
  async function patch(url, data = {}, config = {}) {
    try {
      const response = await api.patch(url, data, config)
      return response.data
    } catch (error) {
      throw handleError(error)
    }
  }

  /**
   * DELETE request
   */
  async function del(url, config = {}) {
    try {
      const response = await api.delete(url, config)
      return response.data
    } catch (error) {
      throw handleError(error)
    }
  }

  /**
   * Manejo centralizado de errores
   */
  function handleError(error) {
    const message = error.response?.data?.detail || 
                   error.message || 
                   'Error en la solicitud'
    
    return {
      message,
      status: error.response?.status,
      data: error.response?.data
    }
  }

  return {
    get,
    post,
    put,
    patch,
    delete: del
  }
}

----- FILE: src/composables/useAuth.js -----
/**
 * Composable useAuth.js - Gestión de autenticación
 * 
 * Proporciona funciones para:
 * - Login/Register
 * - Logout
 * - Verificación de sesión
 * - Almacenamiento de tokens
 */

import { ref, computed } from 'vue'
import { useRouter } from 'vue-router'
import axios from 'axios'

const API_URL = 'http://localhost:8000/api/v1'

// Estado global de autenticación
const user = ref(null)
const token = ref(localStorage.getItem('access_token'))
const refreshToken = ref(localStorage.getItem('refresh_token'))
const isLoading = ref(false)
const error = ref(null)

// Computed properties
const isAuthenticated = computed(() => !!token.value && !!user.value)
const isAdmin = computed(() => user.value?.role === 'admin')

export function useAuth() {
  const router = useRouter()

  /**
   * Registrar nuevo usuario
   * @param {Object} data - { email, username, full_name, password, phone }
   */
  async function register(data) {
    isLoading.value = true
    error.value = null

    try {
      const response = await axios.post(`${API_URL}/auth/register`, {
        email: data.email,
        username: data.username,
        full_name: data.full_name,
        password: data.password,
        phone: data.phone || null
      })

      user.value = response.data
      return user.value
    } catch (err) {
      error.value = err.response?.data?.detail || 'Error en el registro'
      throw err
    } finally {
      isLoading.value = false
    }
  }

  /**
   * Login
   * @param {string} email - Email del usuario
   * @param {string} password - Contraseña
   */
  async function login(email, password) {
    isLoading.value = true
    error.value = null

    try {
      const response = await axios.post(`${API_URL}/auth/login`, {
        email,
        password
      })

      const { access_token, refresh_token } = response.data

      // Guardar tokens
      token.value = access_token
      refreshToken.value = refresh_token
      localStorage.setItem('access_token', access_token)
      localStorage.setItem('refresh_token', refresh_token)

      // Obtener información del usuario
      await fetchUserInfo()

      return user.value
    } catch (err) {
      error.value = err.response?.data?.detail || 'Email o contraseña incorrectos'
      throw err
    } finally {
      isLoading.value = false
    }
  }

  /**
   * Obtener información del usuario actual
   */
  async function fetchUserInfo() {
    if (!token.value) return null

    try {
      const response = await axios.get(`${API_URL}/auth/me`, {
        headers: {
          Authorization: `Bearer ${token.value}`
        }
      })

      user.value = response.data
      return user.value
    } catch (err) {
      // Token expirado o inválido
      logout()
      throw err
    }
  }

  /**
   * Refrescar access token
   */
  async function refreshAccessToken() {
    if (!refreshToken.value) {
      logout()
      return null
    }

    try {
      const response = await axios.post(`${API_URL}/auth/refresh`, {
        refresh_token: refreshToken.value
      })

      const { access_token, refresh_token: new_refresh_token } = response.data

      token.value = access_token
      refreshToken.value = new_refresh_token
      localStorage.setItem('access_token', access_token)
      localStorage.setItem('refresh_token', new_refresh_token)

      return access_token
    } catch (err) {
      logout()
      throw err
    }
  }

  /**
   * Logout
   */
  function logout() {
    user.value = null
    token.value = null
    refreshToken.value = null
    localStorage.removeItem('access_token')
    localStorage.removeItem('refresh_token')
    router.push('/login')
  }

  /**
   * Verificar autenticación en app init
   */
  async function checkAuth() {
    if (token.value) {
      try {
        await fetchUserInfo()
      } catch (err) {
        logout()
      }
    }
  }

  return {
    // Estado
    user,
    token,
    refreshToken,
    isLoading,
    error,

    // Computed
    isAuthenticated,
    isAdmin,

    // Métodos
    register,
    login,
    logout,
    checkAuth,
    fetchUserInfo,
    refreshAccessToken
  }
}

----- FILE: src/composables/useCategories.js -----
import { useCategoriesStore } from '@/stores/categories'
export function useCategories() {
  const store = useCategoriesStore()
  return {
    categories: store.categories,
    loading: store.loading,
    error: store.error,
    fetchCategories: store.fetchCategories,
    createCategory: store.createCategory,
    updateCategory: store.updateCategory,
    deleteCategory: store.deleteCategory
  }
}

----- FILE: src/composables/useDiagnostic.js -----
import { ref, computed } from 'vue'
import brandsData from '@/assets/data/brands.json'
import instrumentsData from '@/assets/data/instruments.json'
import faultsData from '@/assets/data/faults.json'

export function useDiagnostic() {
  // State
  const selectedBrand = ref(null)
  const selectedModel = ref(null)
  const selectedFaults = ref([])
  const clientName = ref('')
  const clientEmail = ref('')
  const clientPhone = ref('')
  const equipmentValue = ref(null)

  // Data
  const brands = computed(() => brandsData.brands)
  const instruments = computed(() => instrumentsData.instruments)
  const faults = computed(() => faultsData.faults)

  /**
   * Get all available brands
   */
  const getBrands = () => brands.value

  /**
   * Get models for a specific brand
   */
  const getModelsByBrand = (brandId) => {
    return instruments.value.filter(item => item.brand === brandId)
  }

  /**
   * Get a specific instrument details
   */
  const getInstrument = (instrumentId) => {
    return instruments.value.find(item => item.id === instrumentId)
  }

  /**
   * Get brand details
   */
  const getBrand = (brandId) => {
    return brands.value.find(item => item.id === brandId)
  }

  /**
   * Get applicable components for an instrument
   */
  const getApplicableComponents = (instrumentId) => {
    const instrument = getInstrument(instrumentId)
    if (!instrument) return []

    const applicableComponents = []

    // Keyboard components
    if (instrument.components.faders > 0) {
      applicableComponents.push({
        type: 'faders',
        count: instrument.components.faders,
        faultIds: ['FADER_INTERMITTENT']
      })
    }

    if (instrument.components.encoders_rotativos > 0) {
      applicableComponents.push({
        type: 'encoders',
        count: instrument.components.encoders_rotativos,
        faultIds: ['ENCODER_INTERMITTENT']
      })
    }

    if (instrument.components.botones > 0) {
      applicableComponents.push({
        type: 'buttons',
        count: instrument.components.botones,
        faultIds: ['BUTTON_STUCK', 'BUTTON_DEAD']
      })
    }

    // Keyboard
    if ('teclado' in instrument.type.toLowerCase()) {
      applicableComponents.push({
        type: 'keyboard',
        faultIds: ['KEYBOARD_DEAD_KEY', 'KEYBOARD_STUCK_KEY', 'AFTERTOUCH_BROKEN']
      })
    }

    // LCD
    if (instrument.components.lcd) {
      applicableComponents.push({
        type: 'lcd',
        faultIds: ['LCD_DEAD', 'LCD_LOW_CONTRAST']
      })
    }

    // Connectivity
    if (instrument.components.usb) {
      applicableComponents.push({
        type: 'usb',
        faultIds: ['USB_NOT_RECOGNIZED']
      })
    }

    if (instrument.components.midi_din) {
      applicableComponents.push({
        type: 'midi',
        faultIds: ['MIDI_NOT_RECOGNIZED']
      })
    }

    // Wheels
    if (instrument.components.rueda_pitch) {
      applicableComponents.push({
        type: 'pitch_wheel',
        faultIds: ['PITCH_WHEEL_BROKEN']
      })
    }

    return applicableComponents
  }

  /**
   * Get available faults for current selection
   */
  const getAvailableFaults = () => {
    if (!selectedModel.value) return Object.values(faults.value)

    const instrument = getInstrument(selectedModel.value)
    if (!instrument) return Object.values(faults.value)

    // Get faults specific to this instrument type
    const applicableComponents = getApplicableComponents(selectedModel.value)
    const applicableFaultIds = new Set()

    // Add all applicable faults from components
    applicableComponents.forEach(component => {
      component.faultIds.forEach(faultId => {
        applicableFaultIds.add(faultId)
      })
    })

    // Always add general faults
    applicableFaultIds.add('POWER')
    applicableFaultIds.add('POWER_UNSTABLE')
    applicableFaultIds.add('AUDIO_DISTORTED')
    applicableFaultIds.add('AUDIO_NO_OUTPUT')
    applicableFaultIds.add('AUDIO_WEAK')
    applicableFaultIds.add('COSMETIC_DAMAGE')
    applicableFaultIds.add('WATER_DAMAGE')
    applicableFaultIds.add('CAPACITOR_BLOWN')
    applicableFaultIds.add('CONNECTOR_LOOSE')

    return Array.from(applicableFaultIds)
      .map(faultId => faults.value[faultId])
      .filter(fault => fault)
  }

  /**
   * Add a fault to the selection
   */
  const addFault = (faultId) => {
    const fault = faults.value[faultId]
    if (!fault) return

    // Check for precedence faults
    if (fault.isPrecedence) {
      selectedFaults.value = [faultId]
    } else {
      // Check if any precedence fault is already selected
      const hasPrecedence = selectedFaults.value.some(id => faults.value[id]?.isPrecedence)

      if (!hasPrecedence && !selectedFaults.value.includes(faultId)) {
        selectedFaults.value.push(faultId)
      }
    }
  }

  /**
   * Remove a fault from the selection
   */
  const removeFault = (faultId) => {
    selectedFaults.value = selectedFaults.value.filter(id => id !== faultId)
  }

  /**
   * Clear all selected faults
   */
  const clearFaults = () => {
    selectedFaults.value = []
  }

  /**
   * Get effective faults (considering precedence rules)
   */
  const getEffectiveFaults = () => {
    // Check for precedence faults
    const precedenceFault = selectedFaults.value.find(id => faults.value[id]?.isPrecedence)

    if (precedenceFault) {

----- FILE: src/composables/useDiagnostics.js -----
import { useDiagnosticsStore } from '@/stores/diagnostics'
export function useDiagnostics() {
  const store = useDiagnosticsStore()
  return {
    diagnostics: store.diagnostics,
    loading: store.loading,
    error: store.error,
    fetchDiagnostics: store.fetchDiagnostics,
    createDiagnostic: store.createDiagnostic,
    updateDiagnostic: store.updateDiagnostic,
    deleteDiagnostic: store.deleteDiagnostic
  }
}

----- FILE: src/composables/useInstruments.js -----
import { useInstrumentsStore } from '@/stores/instruments'
export function useInstruments() {
  const store = useInstrumentsStore()
  return {
    instruments: store.instruments,
    loading: store.loading,
    error: store.error,
    fetchInstruments: store.fetchInstruments,
    createInstrument: store.createInstrument,
    updateInstrument: store.updateInstrument,
    deleteInstrument: store.deleteInstrument
  }
}

----- FILE: src/composables/useInstrumentsCatalog.js -----
import { ref, computed } from 'vue'
import brandsData from '@/assets/data/brands.json'
import instrumentsData from '@/assets/data/instruments.json'

/**
 * useInstrumentsCatalog - Central data catalog for brands and instruments
 * 
 * This composable provides:
 * - Unified access to brands and instruments
 * - Brand → Instruments mapping
 * - Image path generation based on instrument ID
 * - No database needed; all data derived from JSON
 */
export function useInstrumentsCatalog() {
  // Raw data
  const brands = ref(brandsData.brands || [])
  const instruments = ref(instrumentsData.instruments || [])

  /**
   * Get a brand by ID
   */
  const getBrandById = (brandId) => {
    return brands.value.find(b => b.id === brandId)
  }

  /**
   * Get all brands, optionally sorted A→Z
   */
  const getAllBrands = (sorted = true) => {
    const list = [...brands.value]
    if (sorted) {
      return list.sort((a, b) => a.name.localeCompare(b.name))
    }
    return list
  }

  /**
   * Get instruments for a specific brand
   * Returns array of instrument objects with image path included
   */
  const getInstrumentsByBrand = (brandId) => {
    return instruments.value
      .filter(inst => inst.brand === brandId)
      .map(inst => enrichInstrument(inst))
      .sort((a, b) => a.model.localeCompare(b.model))
  }

  /**
   * Get a specific instrument by ID
   */
  const getInstrumentById = (instrumentId) => {
    const inst = instruments.value.find(i => i.id === instrumentId)
    return inst ? enrichInstrument(inst) : null
  }

  /**
   * Generate image path for an instrument
   * Convention: /images/instruments/{instrument.id}.jpg
   * Falls back to placeholder if not found
   */
  const getInstrumentImage = (instrument) => {
    // Priority 1: Use existing imagen_url if valid
    if (instrument?.imagen_url) {
      return instrument.imagen_url
    }

    // Priority 2: Generate from convention
    if (instrument?.id) {
      return `/images/instruments/${instrument.id}.jpg`
    }

    // Priority 3: Placeholder
    return '/images/placeholder.svg'
  }

  /**
   * Enrich instrument object with computed fields
   * (adds image path, formatted price, etc.)
   */
  const enrichInstrument = (inst) => {
    if (!inst) return null

    return {
      ...inst,
      imagePath: getInstrumentImage(inst),
      estimatedPrice: inst.valor_estimado
        ? Math.round(
            (inst.valor_estimado.min + inst.valor_estimado.max) / 2
          )
        : 0,
      displayName: `${inst.model} (${inst.year || '?'})`,
      brandLabel: getBrandById(inst.brand)?.name || inst.brand
    }
  }

  /**
   * Search instruments by text
   */
  const searchInstruments = (query) => {
    if (!query || query.trim() === '') return []

    const lower = query.toLowerCase()
    return instruments.value
      .filter(
        inst =>
          inst.model.toLowerCase().includes(lower) ||
          inst.brand.toLowerCase().includes(lower) ||
          inst.description?.toLowerCase().includes(lower)
      )
      .map(inst => enrichInstrument(inst))
  }

  /**
   * Get a summary of the catalog
   */
  const getCatalogStats = computed(() => {
    const brandsCount = brands.value.length
    const instrumentsCount = instruments.value.length
    const instrumentsWithImage = instruments.value.filter(
      i => i.imagen_url || i.image?.url
    ).length

    return {
      totalBrands: brandsCount,
      totalInstruments: instrumentsCount,
      instrumentsWithImage,
      coverage: instrumentsCount > 0
        ? Math.round((instrumentsWithImage / instrumentsCount) * 100)
        : 0
    }
  })

  return {
    // Data refs
    brands,
    instruments,

    // Query methods
    getBrandById,
    getAllBrands,
    getInstrumentsByBrand,
    getInstrumentById,
    getInstrumentImage,
    searchInstruments,

    // Stats
    getCatalogStats
  }
}

----- FILE: src/composables/useInventory.js -----

----- FILE: src/composables/useRepairs.js -----
import { useRepairsStore } from '@/stores/repairs'
export function useRepairs() {
  const store = useRepairsStore()
  return {
    repairs: store.repairs,
    loading: store.loading,
    error: store.error,
    fetchRepairs: store.fetchRepairs,
    createRepair: store.createRepair,
    updateRepair: store.updateRepair,
    deleteRepair: store.deleteRepair
  }
}

----- FILE: src/composables/useStockMovements.js -----
import { useStockMovementsStore } from '@/stores/stockMovements'
export function useStockMovements() {
  const store = useStockMovementsStore()
  return {
    movements: store.movements,
    loading: store.loading,
    error: store.error,
    fetchMovements: store.fetchMovements,
    createMovement: store.createMovement
  }
}

----- FILE: src/composables/useUsers.js -----
import { useUsersStore } from '@/stores/users'
export function useUsers() {
  const store = useUsersStore()
  return {
    users: store.users,
    loading: store.loading,
    error: store.error,
    fetchUsers: store.fetchUsers,
    createUser: store.createUser,
    updateUser: store.updateUser,
    deleteUser: store.deleteUser
  }
}

----- FILE: src/main.js -----
import "./scss/style.scss"
import { createApp } from "vue"
import { createPinia } from "pinia"
import App from "/src/vue/stack/App.vue"
import router from "@/router"
import { useAuthStore } from "@/stores/auth"

const app = createApp(App)

// Install Pinia for state management
const pinia = createPinia()
app.use(pinia)

// Install Vue Router
app.use(router)

// Initialize auth on app startup
const authStore = useAuthStore()
authStore.checkAuth()

// Mount app
app.mount("#app")

----- FILE: src/router/index.js -----
/**
 * Router - Vue Router configuration
 * Define todas las rutas de la aplicación
 */

import { createRouter, createWebHistory } from 'vue-router'
import { useAuthStore } from '@/stores/auth'

// Layouts
import Master from '@/vue/content/Master.vue'

// Pages
import HomePage from '@/vue/content/pages/HomePage.vue'
import LoginPage from '@/vue/content/pages/LoginPage.vue'
import RegisterPage from '@/vue/content/pages/RegisterPage.vue'
import DashboardPage from '@/vue/content/pages/DashboardPage.vue'
import RepairsPage from '@/vue/content/pages/RepairsPage.vue'
import ProfilePage from '@/vue/content/pages/ProfilePage.vue'
import CotizadorIAPage from '@/vue/content/pages/CotizadorIAPage.vue'
import LicensePage from '@/vue/content/pages/LicensePage.vue'
import PolicyPage from '@/vue/content/pages/PolicyPage.vue'

// Admin Pages
import AdminDashboard from '@/vue/content/pages/admin/AdminDashboard.vue'
import InventoryPage from '@/vue/content/pages/admin/InventoryPage.vue'
import ClientsPage from '@/vue/content/pages/admin/ClientsPage.vue'
import RepairsAdminPage from '@/vue/content/pages/admin/RepairsAdminPage.vue'
import StatsPage from '@/vue/content/pages/admin/StatsPage.vue'
import CategoriesPage from '@/vue/content/pages/admin/CategoriesPage.vue'

const routes = [
  // Public routes
  {
    path: '/',
    component: Master,
    children: [
      {
        path: '',
        name: 'home',
        component: HomePage
      },
      {
        path: 'license',
        name: 'license',
        component: LicensePage
      },
      {
        path: 'policy',
        name: 'policy',
        component: PolicyPage
      }
    ]
  },

  // Auth routes
  {
    path: '/login',
    name: 'login',
    component: LoginPage,
    meta: { requiresAuth: false, requiresGuest: true }
  },
  {
    path: '/register',
    name: 'register',
    component: RegisterPage,
    meta: { requiresAuth: false, requiresGuest: true }
  },

  // Client routes (requieren autenticación)
  {
    path: '/dashboard',
    name: 'dashboard',
    component: DashboardPage,
    meta: { requiresAuth: true }
  },
  {
    path: '/repairs',
    name: 'repairs',
    component: RepairsPage,
    meta: { requiresAuth: true }
  },
  {
    path: '/profile',
    name: 'profile',
    component: ProfilePage,
    meta: { requiresAuth: true }
  },
  {
    path: '/cotizador-ia',
    name: 'cotizador-ia',
    component: CotizadorIAPage,
    meta: { requiresAuth: true }
  },

  // Admin routes (requieren autenticación y rol admin)
  {
    path: '/admin',
    component: Master,
    meta: { requiresAuth: true, requiresAdmin: true },
    children: [
      {
        path: '',
        name: 'admin-dashboard',
        component: AdminDashboard
      },
      {
        path: 'inventory',
        name: 'admin-inventory',
        component: InventoryPage
      },
      {
        path: 'clients',
        name: 'admin-clients',
        component: ClientsPage
      },
      {
        path: 'repairs',
        name: 'admin-repairs',
        component: RepairsAdminPage
      },
      {
        path: 'stats',
        name: 'admin-stats',
        component: StatsPage
      },
      {
        path: 'categories',
        name: 'admin-categories',
        component: CategoriesPage
      }
    ]
  },

  // 404 - Ruta no encontrada
  {
    path: '/:pathMatch(.*)*',
    redirect: '/'
  }
]

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL || '/'),
  routes
})

/**
 * Navigation guards - Proteger rutas según autenticación
 */
router.beforeEach(async (to, from, next) => {
  const authStore = useAuthStore()

  // Verificar autenticación si no está hecho aún
  if (!authStore.token && to.meta.requiresAuth) {
    // Intentar recuperar sesión del localStorage
    await authStore.checkAuth()
  }

  // Ruta requiere autenticación
  if (to.meta.requiresAuth && !authStore.isAuthenticated) {
    next({ name: 'login', query: { redirect: to.fullPath } })
    return
  }

  // Ruta requiere rol admin
  if (to.meta.requiresAdmin && !authStore.isAdmin) {
    next({ name: 'home' })
    return
  }

  // Ruta requiere que NO esté autenticado (login, register)
  if (to.meta.requiresGuest && authStore.isAuthenticated) {
    next({ name: 'dashboard' })
    return
  }

  next()
})

export default router

----- FILE: src/stores/auth.js -----
/**
 * Store Pinia - auth.js
 * Gestiona el estado global de autenticación
 * 
 * Uso en componentes:
 * import { useAuthStore } from '@/stores/auth'
 * const auth = useAuthStore()
 * auth.login(email, password)
 */

import { defineStore } from 'pinia'
import { useAuth } from '@/composables/useAuth'

export const useAuthStore = defineStore('auth', () => {
  const authComposable = useAuth()

  // State properties
  const user = authComposable.user
  const token = authComposable.token
  const refreshToken = authComposable.refreshToken
  const isLoading = authComposable.isLoading
  const error = authComposable.error

  // Computed properties
  const isAuthenticated = authComposable.isAuthenticated
  const isAdmin = authComposable.isAdmin

  // Actions
  const register = authComposable.register
  const login = authComposable.login
  const logout = authComposable.logout
  const checkAuth = authComposable.checkAuth
  const fetchUserInfo = authComposable.fetchUserInfo
  const refreshAccessToken = authComposable.refreshAccessToken

  return {
    // State
    user,
    token,
    refreshToken,
    isLoading,
    error,

    // Computed
    isAuthenticated,
    isAdmin,

    // Actions
    register,
    login,
    logout,
    checkAuth,
    fetchUserInfo,
    refreshAccessToken
  }
})

----- FILE: src/stores/categories.js -----
import { defineStore } from 'pinia'
import { useApi } from '@/composables/useApi'

export const useCategoriesStore = defineStore('categories', {
  state: () => ({
    categories: [],
    loading: false,
    error: null
  }),
  actions: {
    async fetchCategories() {
      this.loading = true
      try {
        this.categories = await useApi().get('/api/categories')
      } catch (e) {
        this.error = e
      } finally {
        this.loading = false
      }
    },
    async createCategory(data) {
      return await useApi().post('/api/categories', data)
    },
    async updateCategory(id, data) {
      return await useApi().put(`/api/categories/${id}`, data)
    },
    async deleteCategory(id) {
      return await useApi().delete(`/api/categories/${id}`)
    }
  }
})

----- FILE: src/stores/diagnostics.js -----
import { defineStore } from 'pinia'
import { useApi } from '@/composables/useApi'

export const useDiagnosticsStore = defineStore('diagnostics', {
  state: () => ({
    diagnostics: [],
    loading: false,
    error: null
  }),
  actions: {
    async fetchDiagnostics() {
      this.loading = true
      try {
        this.diagnostics = await useApi().get('/api/diagnostics')
      } catch (e) {
        this.error = e
      } finally {
        this.loading = false
      }
    },
    async createDiagnostic(data) {
      return await useApi().post('/api/diagnostics', data)
    },
    async updateDiagnostic(id, data) {
      return await useApi().put(`/api/diagnostics/${id}`, data)
    },
    async deleteDiagnostic(id) {
      return await useApi().delete(`/api/diagnostics/${id}`)
    }
  }
})

----- FILE: src/stores/instruments.js -----
import { defineStore } from 'pinia'
import { useApi } from '@/composables/useApi'

export const useInstrumentsStore = defineStore('instruments', {
  state: () => ({
    instruments: [],
    loading: false,
    error: null
  }),
  actions: {
    async fetchInstruments() {
      this.loading = true
      try {
        this.instruments = await useApi().get('/api/instruments')
      } catch (e) {
        this.error = e
      } finally {
        this.loading = false
      }
    },
    async createInstrument(data) {
      return await useApi().post('/api/instruments', data)
    },
    async updateInstrument(id, data) {
      return await useApi().put(`/api/instruments/${id}`, data)
    },
    async deleteInstrument(id) {
      return await useApi().delete(`/api/instruments/${id}`)
    }
  }
})

----- FILE: src/stores/inventory.js -----

----- FILE: src/stores/repairs.js -----
import { defineStore } from 'pinia'
import { useApi } from '@/composables/useApi'

export const useRepairsStore = defineStore('repairs', {
  state: () => ({
    repairs: [],
    loading: false,
    error: null
  }),
  actions: {
    async fetchRepairs() {
      this.loading = true
      try {
        this.repairs = await useApi().get('/api/repairs')
      } catch (e) {
        this.error = e
      } finally {
        this.loading = false
      }
    },
    async createRepair(data) {
      return await useApi().post('/api/repairs', data)
    },
    async updateRepair(id, data) {
      return await useApi().put(`/api/repairs/${id}`, data)
    },
    async deleteRepair(id) {
      return await useApi().delete(`/api/repairs/${id}`)
    }
  }
})

----- FILE: src/stores/stockMovements.js -----
import { defineStore } from 'pinia'
import { useApi } from '@/composables/useApi'

export const useStockMovementsStore = defineStore('stockMovements', {
  state: () => ({
    movements: [],
    loading: false,
    error: null
  }),
  actions: {
    async fetchMovements() {
      this.loading = true
      try {
        this.movements = await useApi().get('/api/stock-movements')
      } catch (e) {
        this.error = e
      } finally {
        this.loading = false
      }
    },
    async createMovement(data) {
      return await useApi().post('/api/stock-movements', data)
    }
  }
})

----- FILE: src/stores/users.js -----
import { defineStore } from 'pinia'
import { useApi } from '@/composables/useApi'

export const useUsersStore = defineStore('users', {
  state: () => ({
    users: [],
    loading: false,
    error: null
  }),
  actions: {
    async fetchUsers() {
      this.loading = true
      try {
        this.users = await useApi().get('/api/users')
      } catch (e) {
        this.error = e
      } finally {
        this.loading = false
      }
    },
    async createUser(data) {
      return await useApi().post('/api/users', data)
    },
    async updateUser(id, data) {
      return await useApi().put(`/api/users/${id}`, data)
    },
    async deleteUser(id) {
      return await useApi().delete(`/api/users/${id}`)
    }
  }
})

----- FILE: src/vue/stack/App.vue -----
<template>
    <StateProviderLayer>
        <FeedbacksLayer>
            <ContentLayer>
                <Master/>
            </ContentLayer>
        </FeedbacksLayer>
    </StateProviderLayer>
    
    <!-- Botón flotante global -->
    <FloatingQuoteButton />
</template>

<script setup>
import StateProviderLayer from "/src/vue/stack/StateProviderLayer.vue"
import FeedbacksLayer from "/src/vue/stack/FeedbacksLayer.vue"
import ContentLayer from "/src/vue/stack/ContentLayer.vue"
import Master from "/src/vue/content/Master.vue"
import FloatingQuoteButton from "/src/vue/components/widgets/FloatingQuoteButton.vue"  // ← AGREGAR
import {useEmails} from "/src/composables/emails.js"
import {onMounted} from "vue"

const emails = useEmails()

onMounted(() => {
    emails.init()
})
</script>

<style lang="scss" scoped>
</style>
========== FRONTEND COMPONENTES (ÍNDICE) =========
src/vue/components/admin/CategoryForm.vue
src/vue/components/admin/CategoryList.vue
src/vue/components/admin/CategoryManager.vue
src/vue/components/admin/ClientDetail.vue
src/vue/components/admin/ClientList.vue
src/vue/components/admin/DiagnosticsList.vue
src/vue/components/admin/InstrumentForm.vue
src/vue/components/admin/InstrumentList.vue
src/vue/components/admin/InventoryAlerts.vue
src/vue/components/admin/InventoryForm.vue
src/vue/components/admin/InventoryTable.vue
src/vue/components/admin/RepairForm.vue
src/vue/components/admin/RepairManager.vue
src/vue/components/admin/RepairStatusEditor.vue
src/vue/components/admin/RepairsList.vue
src/vue/components/admin/StatsCards.vue
src/vue/components/admin/StockMovements.vue
src/vue/components/admin/StockMovementsList.vue
src/vue/components/admin/UserForm.vue
src/vue/components/admin/UserList.vue
src/vue/components/ai/AIAnalysisResult.vue
src/vue/components/ai/FaultDetector.vue
src/vue/components/ai/FaultMarker.vue
src/vue/components/ai/ImageUploader.vue
src/vue/components/ai/QuoteGenerator.vue
src/vue/components/articles/ArticleCustomContent.vue
src/vue/components/articles/ArticleFaq.vue
src/vue/components/articles/ArticleFeatures.vue
src/vue/components/articles/ArticleInfoBlock.vue
src/vue/components/articles/ArticleParagraph.vue
src/vue/components/articles/ArticleProjectGrid.vue
src/vue/components/articles/ArticleQuotes.vue
src/vue/components/articles/ArticleTestimonials.vue
src/vue/components/articles/ArticleTimeline.vue
src/vue/components/articles/DiagnosticWizard.vue
src/vue/components/articles/items/ItemFaqQuestion.vue
src/vue/components/articles/items/ItemFeature.vue
src/vue/components/articles/items/ItemProjectGrid.vue
src/vue/components/articles/items/ItemQuote.vue
src/vue/components/articles/items/ItemTestimonial.vue
src/vue/components/articles/items/ItemTimelineEntry.vue
src/vue/components/auth/AccountDelete.vue
src/vue/components/auth/LoginForm.vue
src/vue/components/auth/PasswordReset.vue
src/vue/components/auth/RegisterForm.vue
src/vue/components/dashboard/DashboardPanel.vue
src/vue/components/dashboard/QuickStats.vue
src/vue/components/dashboard/RepairCard.vue
src/vue/components/dashboard/RepairTimeline.vue
src/vue/components/dashboard/RepairsList.vue
src/vue/components/dashboard/StatusBadge.vue
src/vue/components/dashboard/UserProfile.vue
src/vue/components/footer/Footer.vue
src/vue/components/footer/FooterBlock.vue
src/vue/components/footer/FooterColumn.vue
src/vue/components/footer/FooterCopyright.vue
src/vue/components/forms/contact/ContactForm.vue
src/vue/components/forms/contact/ContactFormFields.vue
src/vue/components/forms/contact/ContactFormSuccess.vue
src/vue/components/generic/ImageView.vue
src/vue/components/generic/Link.vue
src/vue/components/layout/BackgroundPromo.vue
src/vue/components/layout/PageHeader.vue
src/vue/components/layout/PageSection.vue
src/vue/components/layout/PageSectionContent.vue
src/vue/components/layout/PageSectionFooter.vue
src/vue/components/layout/PageSectionHeader.vue
src/vue/components/layout/PageWrapper.vue
src/vue/components/loaders/ActivitySpinner.vue
src/vue/components/loaders/Loader.vue
src/vue/components/nav/Navigation.vue
src/vue/components/nav/navbar-wrappers/InPageNavbar.vue
src/vue/components/nav/navbar-wrappers/RouteNavbar.vue
src/vue/components/nav/navbar/Navbar.vue
src/vue/components/nav/navbar/NavbarBrand.vue
src/vue/components/nav/navbar/NavbarLinks.vue
src/vue/components/nav/navbar/NavbarToggleButton.vue
src/vue/components/projects/ProjectInfo.vue
src/vue/components/projects/ProjectInfoContent.vue
src/vue/components/projects/ProjectInfoFeaturedContent.vue
src/vue/components/projects/ProjectModal.vue
src/vue/components/widgets/Alert.vue
src/vue/components/widgets/Breadcrumbs.vue
src/vue/components/widgets/CircleIcon.vue
src/vue/components/widgets/Divider.vue
src/vue/components/widgets/FilterTabs.vue
src/vue/components/widgets/FloatingQuoteButton.vue
src/vue/components/widgets/InlineLinkList.vue
src/vue/components/widgets/ProgressBar.vue
src/vue/components/widgets/QuotedText.vue
src/vue/components/widgets/SocialLinks.vue
src/vue/components/widgets/Spinner.vue
src/vue/components/widgets/XLButton.vue
src/vue/content/Master.vue
src/vue/content/pages/CotizadorIAPage.vue
src/vue/content/pages/DashboardPage.vue
src/vue/content/pages/HomePage.vue
src/vue/content/pages/LicensePage.vue
src/vue/content/pages/LoginPage.vue
src/vue/content/pages/PolicyPage.vue
src/vue/content/pages/ProfilePage.vue
src/vue/content/pages/RegisterPage.vue
src/vue/content/pages/RepairsPage.vue
src/vue/content/pages/admin/AdminDashboard.vue
src/vue/content/pages/admin/CategoriesPage.vue
src/vue/content/pages/admin/ClientsPage.vue
src/vue/content/pages/admin/InventoryPage.vue
src/vue/content/pages/admin/RepairsAdminPage.vue
src/vue/content/pages/admin/StatsPage.vue
src/vue/content/sections/AboutSection.vue
src/vue/content/sections/ContactSection.vue
src/vue/content/sections/FaqSection.vue
src/vue/content/sections/FeaturedProjectSection.vue
src/vue/content/sections/HeroSection.vue
src/vue/content/sections/HistorySection.vue
src/vue/content/sections/LicenseSection.vue
src/vue/content/sections/PolicySection.vue
src/vue/content/sections/PortfolioSection.vue
src/vue/content/sections/ReviewsSection.vue
src/vue/content/sections/ServicesSection.vue
src/vue/content/sections/TeamSection.vue
src/vue/sections/DiagnosticSection.vue
src/vue/stack/App.vue
src/vue/stack/ContentLayer.vue
src/vue/stack/FeedbacksLayer.vue
src/vue/stack/StateProviderLayer.vue

=============== BACKEND API ======================

"""
Endpoints de autenticación: login, register, logout
"""
from fastapi import APIRouter, HTTPException, status, Request
from sqlalchemy.orm import Session
from fastapi.params import Depends
from backend.app.core.database import get_db
from backend.app.core.security import (
    hash_password, verify_password, create_access_token, create_refresh_token
)
from backend.app.core.dependencies import get_current_user
from backend.app.core.ratelimit import limiter
from backend.app.services.logging_service import create_audit
from backend.app.models.user import User
from backend.app.schemas.auth import (
    LoginRequest, RegisterRequest, Token, PasswordResetRequest
)
from backend.app.schemas.user import UserResponse

router = APIRouter(prefix="/auth", tags=["auth"])


@router.post("/register", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
async def register(
    request: RegisterRequest,
    db: Session = Depends(get_db)
):
    """
    Registrar un nuevo usuario
    
    - **email**: Email único del usuario
    - **username**: Username único (3-100 caracteres)
    - **full_name**: Nombre completo (3+ caracteres)
    - **password**: Contraseña (8+ caracteres)
    - **phone**: Teléfono (opcional)
    """
    
    # Verificar si el email ya existe
    existing_email = db.query(User).filter(User.email == request.email).first()
    if existing_email:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email ya registrado"
        )
    
    # Verificar si el username ya existe
    existing_username = db.query(User).filter(User.username == request.username).first()
    if existing_username:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Username ya existe"
        )
    
    # Crear nuevo usuario
    new_user = User(
        email=request.email,
        username=request.username,
        full_name=request.full_name,
        hashed_password=hash_password(request.password),
        phone=request.phone
    )
    
    db.add(new_user)
    db.commit()
    db.refresh(new_user)
    # Audit registration
    try:
        create_audit(event_type="auth.register", user_id=new_user.id, ip_address=None, metadata={"email": new_user.email, "username": new_user.username})
    except Exception:
        pass
    
    return new_user


@router.post("/login", response_model=Token)
@limiter.limit("5/minute")  # limit login attempts to mitigate brute-force
async def login(
    request: Request,
    payload: LoginRequest,
    db: Session = Depends(get_db)
):
    """
    Login: obtener token de acceso
    
    - **email**: Email del usuario
    - **password**: Contraseña
    
    Retorna:
    - **access_token**: JWT token para usar en endpoints protegidos
    - **refresh_token**: Token para obtener nuevo access_token
    """
    
    # Buscar usuario por email (gracefully handle DB issues during tests)
    try:
        user = db.query(User).filter(User.email == payload.email).first()
    except Exception as e:
        # In test or minimal environments the DB may not be initialized; treat as invalid credentials
        # and let rate limiting still apply without raising an internal error.
        user = None
    if not user:
        # Audit failed login attempt
        try:
            ip = getattr(request.client, "host", None)
            create_audit(event_type="auth.login.failed", user_id=None, ip_address=ip, details={"email": payload.email})
        except Exception:
            pass
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Email o contraseña incorrectos"
        )
    
    # Verificar contraseña
    if not user or not verify_password(payload.password, user.hashed_password):
        # Audit failed login attempt
        try:
            ip = getattr(request.client, "host", None)
            create_audit(event_type="auth.login.failed", user_id=(user.id if user else None), ip_address=ip, details={"email": payload.email})
        except Exception:
            pass
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Email o contraseña incorrectos"
        )
    
    # Verificar que el usuario esté activo
    if not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Usuario inactivo"
        )
    
    # Crear tokens
    access_token = create_access_token(data={
        "sub": str(user.id),
        "username": user.username,
        "email": user.email,
        "role": user.role.value
    })
    
    refresh_token = create_refresh_token(data={
        "sub": str(user.id)
    })
    # Audit successful login
    try:
        ip = getattr(request.client, "host", None)
        create_audit(event_type="auth.login.success", user_id=user.id, ip_address=ip, details={"username": user.username})
    except Exception:
        pass
    
    return {
        "access_token": access_token,
        "refresh_token": refresh_token,
        "token_type": "bearer"
    }


@router.post("/logout")
async def logout(user: dict = Depends(get_current_user)):
    """
    Logout: invalida el token actual (cliente)
    
    En la práctica, el logout se maneja desde el frontend
    eliminando el token del localStorage.
    Este endpoint es opcional para implementar blacklist en backend.
    """
    return {"message": "Logout exitoso"}


@router.get("/me", response_model=UserResponse)
async def get_current_user_info(
    user: dict = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Obtener información del usuario actual (autenticado)
    
    Requiere: Header Authorization: Bearer {token}
    """
    user_obj = db.query(User).filter(User.id == int(user["user_id"])).first()
    if not user_obj:
        raise HTTPException(status_code=404, detail="Usuario no encontrado")
    
    return user_obj


@router.post("/refresh")
async def refresh_access_token(refresh_token: str):
    """
    Refrescar access token usando refresh token
    
    - **refresh_token**: Token de refresco obtenido en login
    
    Retorna nuevo access_token y refresh_token
    """
    from backend.app.core.security import verify_refresh_token
    
    try:
        payload = verify_refresh_token(refresh_token)
        user_id = payload.get("sub")
        

----- FILE: backend/app/api/v1/endpoints/brands.py -----
from fastapi import APIRouter
from typing import List
import json
from pathlib import Path

router = APIRouter(prefix="/brands", tags=["brands"])

DATA_PATH = Path(__file__).resolve().parents[5] / "src" / "assets" / "data"

@router.get("/", response_model=List[dict])
async def list_brands():
    """Return list of brands sorted A-Z by name"""
    with open(DATA_PATH / "brands.json", "r", encoding="utf-8") as f:
        data = json.load(f)
    brands = data.get("brands", [])
    sorted_brands = sorted(brands, key=lambda b: b.get("name", "").lower())
    # Return minimal fields
    return [{"id": b["id"], "name": b["name"], "tier": b.get("tier")} for b in sorted_brands]

@router.get("/{brand_id}/models", response_model=List[dict])
async def list_models_by_brand(brand_id: str):
    """Return instruments for a given brand with image metadata"""
    with open(DATA_PATH / "instruments.json", "r", encoding="utf-8") as f:
        data = json.load(f)
    instruments = [i for i in data.get("instruments", []) if i.get("brand") == brand_id]
    sorted_instruments = sorted(instruments, key=lambda i: i.get("model", "").lower())
    # Return basic info + image metadata
    return [
        {
            "id": i["id"],
            "model": i["model"],
            "year": i.get("year"),
            "description": i.get("description"),
            "imagen_url": i.get("imagen_url"),
            "image": i.get("image", {"url": None, "status": "pending"}),
            "valor_estimado": i.get("valor_estimado")
        }
        for i in sorted_instruments
    ]

----- FILE: backend/app/api/v1/endpoints/categories.py -----

----- FILE: backend/app/api/v1/endpoints/diagnostics.py -----

----- FILE: backend/app/api/v1/endpoints/instruments.py -----
from fastapi import APIRouter, HTTPException
from pathlib import Path
import json

router = APIRouter(prefix="/instruments", tags=["instruments"]) 

DATA_PATH = Path(__file__).resolve().parents[5] / "src" / "assets" / "data"

@router.get("/{instrument_id}")
async def get_instrument(instrument_id: str):
    with open(DATA_PATH / "instruments.json", "r", encoding="utf-8") as f:
        data = json.load(f)
    instruments = data.get("instruments", [])
    inst = next((i for i in instruments if i.get("id") == instrument_id), None)
    if not inst:
        raise HTTPException(status_code=404, detail="Instrument not found")
    return inst

@router.get("/{instrument_id}/image")
async def get_instrument_image(instrument_id: str):
    # Return imagen_url as-is; frontend should handle relative paths
    with open(DATA_PATH / "instruments.json", "r", encoding="utf-8") as f:
        data = json.load(f)
    instruments = data.get("instruments", [])
    inst = next((i for i in instruments if i.get("id") == instrument_id), None)
    if not inst:
        raise HTTPException(status_code=404, detail="Instrument not found")
    img = inst.get("imagen_url")
    if not img:
        raise HTTPException(status_code=404, detail="No image for instrument")
    return {"imagen_url": img}

----- FILE: backend/app/api/v1/endpoints/inventory.py -----

----- FILE: backend/app/api/v1/endpoints/repairs.py -----

----- FILE: backend/app/api/v1/endpoints/stats.py -----

----- FILE: backend/app/api/v1/endpoints/users.py -----

----- FILE: backend/app/api/v1/router.py -----
from fastapi import APIRouter
from .endpoints import brands, instruments, auth
from backend.app.routers import uploads as uploads_router

# Routers adicionales (creados por copilot) - si existen, se incluyen
try:
	from backend.app.routers import user as user_router
	from backend.app.routers import repair as repair_router
	from backend.app.routers import instrument as instrument_router
	from backend.app.routers import category as category_router
	from backend.app.routers import stock_movement as stock_movement_router
	from backend.app.routers import contact as contact_router
	from backend.app.routers import diagnostic as diagnostic_router
	from backend.app.routers import payments as payments_router
except Exception:
	# Si los módulos no existen en este entorno, se ignoran
	user_router = repair_router = instrument_router = category_router = stock_movement_router = contact_router = None

# If any router failed to import previously (e.g., due to transient import errors),
# attempt a second import pass so that fixes applied at runtime are picked up.
import importlib
for name in ("repair", "user", "instrument", "category", "stock_movement", "contact"):
	var_name = f"{name}_router"
	if globals().get(var_name) is None:
		try:
			mod = importlib.import_module(f"backend.app.routers.{name}")
			globals()[var_name] = mod
		except Exception:
			globals()[var_name] = None

# Ensure payments router is also available on a second import pass
if globals().get("payments_router") is None:
	try:
		mod = importlib.import_module("backend.app.routers.payments")
		globals()["payments_router"] = mod
	except Exception:
		globals()["payments_router"] = None

# Ensure diagnostic router is picked up on the second import pass as well
if globals().get("diagnostic_router") is None:
	try:
		mod = importlib.import_module("backend.app.routers.diagnostic")
		globals()["diagnostic_router"] = mod
	except Exception:
		globals()["diagnostic_router"] = None

api_router = APIRouter(prefix="/api/v1")

api_router.include_router(brands.router)
api_router.include_router(instruments.router)
api_router.include_router(auth.router)
api_router.include_router(uploads_router.router)

# Incluir routers adicionales si están disponibles
if user_router:
	api_router.include_router(user_router.router)
if repair_router:
	api_router.include_router(repair_router.router)
if instrument_router:
	api_router.include_router(instrument_router.router)
if category_router:
	api_router.include_router(category_router.router)
if stock_movement_router:
	api_router.include_router(stock_movement_router.router)
if contact_router:
	api_router.include_router(contact_router.router)
if globals().get("diagnostic_router"):
	api_router.include_router(globals()["diagnostic_router"].router)
if globals().get("payments_router"):
	api_router.include_router(globals()["payments_router"].router)


from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from backend.app.models.category import Category
from backend.app.core.database import get_db

router = APIRouter(prefix="/api/categories", tags=["Categories"])

@router.get("/")
def list_categories(db: Session = Depends(get_db)):
    return db.query(Category).all()

@router.post("/")
def create_category(payload: dict, db: Session = Depends(get_db)):
    db_cat = Category(**payload)
    db.add(db_cat)
    db.commit()
    db.refresh(db_cat)
    return db_cat

@router.put("/{category_id}")
def update_category(category_id: int, payload: dict, db: Session = Depends(get_db)):
    db_cat = db.query(Category).get(category_id)
    if not db_cat:
        raise HTTPException(status_code=404, detail="Category not found")
    for k, v in payload.items():
        setattr(db_cat, k, v)
    db.commit()
    db.refresh(db_cat)
    return db_cat

@router.delete("/{category_id}")
def delete_category(category_id: int, db: Session = Depends(get_db)):
    db_cat = db.query(Category).get(category_id)
    if not db_cat:
        raise HTTPException(status_code=404, detail="Category not found")
    db.delete(db_cat)
    db.commit()
    return {"ok": True}

----- FILE: backend/app/routers/contact.py -----
from fastapi import APIRouter, HTTPException

router = APIRouter(prefix="/api/contact", tags=["Contact"])

@router.post("/")
def send_contact(payload: dict):
    # Aquí podrías validar y enviar email o guardar en DB
    # Por ahora solo retornamos OK
    if not payload.get('email') or not payload.get('message'):
        raise HTTPException(status_code=400, detail="Missing email or message")
    return {"ok": True, "received": payload}

----- FILE: backend/app/routers/diagnostic.py -----
"""
API routes for diagnostic and quotation system
"""

from fastapi import APIRouter, HTTPException, Depends
from typing import List
import json
from pathlib import Path

# Avoid importing application schemas directly to keep router import lightweight in tests
from backend.app.core.config import get_settings, Settings
from backend.app.services.logging_service import create_audit

router = APIRouter(prefix="/diagnostic", tags=["diagnostic"])

# Load static data (resolve paths relative to project root)
_root = Path(__file__).resolve().parents[3]
data_dir = _root / "src" / "assets" / "data"
with open(data_dir / "brands.json", "r") as f:
    brands_data = json.load(f)

with open(data_dir / "instruments.json", "r") as f:
    instruments_data = json.load(f)

with open(data_dir / "faults.json", "r") as f:
    faults_data = json.load(f)


@router.get("/instruments/brands")
async def get_brands():
    """Get all available instrument brands"""
    return brands_data["brands"]


@router.get("/instruments/models/{brand_id}")
async def get_models_by_brand(brand_id: str):
    """Get all models for a specific brand"""
    models = [
        instrument
        for instrument in instruments_data["instruments"]
        if instrument["brand"] == brand_id
    ]
    return models


@router.get("/instruments/{instrument_id}")
async def get_instrument(instrument_id: str):
    """Get detailed information about a specific instrument"""
    for instrument in instruments_data["instruments"]:
        if instrument["id"] == instrument_id:
            return instrument
    raise HTTPException(status_code=404, detail="Instrument not found")


@router.get("/faults")
async def get_all_faults():
    """Get all available faults"""
    return faults_data["faults"]


@router.get("/faults/applicable/{instrument_id}")
async def get_applicable_faults(instrument_id: str):
    """Get faults applicable to a specific instrument"""
    # Find the instrument
    instrument = None
    for inst in instruments_data["instruments"]:
        if inst["id"] == instrument_id:
            instrument = inst
            break

    if not instrument:
        raise HTTPException(status_code=404, detail="Instrument not found")

    # Build list of applicable faults based on instrument components
    applicable_faults = {}

    # Always include general faults
    general_fault_ids = [
        "POWER",
        "POWER_UNSTABLE",
        "AUDIO_DISTORTED",
        "AUDIO_NO_OUTPUT",
        "AUDIO_WEAK",
        "COSMETIC_DAMAGE",
        "WATER_DAMAGE",
        "CAPACITOR_BLOWN",
        "CONNECTOR_LOOSE",
    ]

    for fault_id in general_fault_ids:
        if fault_id in faults_data["faults"]:
            applicable_faults[fault_id] = faults_data["faults"][fault_id]

    # Add component-specific faults based on instrument components
    components = instrument["components"]

    # Keyboard faults
    if "teclado" in instrument["type"].lower():
        keyboard_faults = ["KEYBOARD_DEAD_KEY", "KEYBOARD_STUCK_KEY"]
        for fault_id in keyboard_faults:
            if fault_id in faults_data["faults"]:
                applicable_faults[fault_id] = faults_data["faults"][fault_id]

    # LCD faults
    if components.get("lcd"):
        lcd_faults = ["LCD_DEAD", "LCD_LOW_CONTRAST"]
        for fault_id in lcd_faults:
            if fault_id in faults_data["faults"]:
                applicable_faults[fault_id] = faults_data["faults"][fault_id]

    # Control faults
    if components.get("encoders_rotativos", 0) > 0:
        if "ENCODER_INTERMITTENT" in faults_data["faults"]:
            applicable_faults["ENCODER_INTERMITTENT"] = faults_data["faults"][
                "ENCODER_INTERMITTENT"
            ]

    if components.get("faders", 0) > 0:
        if "FADER_INTERMITTENT" in faults_data["faults"]:
            applicable_faults["FADER_INTERMITTENT"] = faults_data["faults"][
                "FADER_INTERMITTENT"
            ]

    if components.get("botones", 0) > 0:
        button_faults = ["BUTTON_STUCK", "BUTTON_DEAD"]
        for fault_id in button_faults:
            if fault_id in faults_data["faults"]:
                applicable_faults[fault_id] = faults_data["faults"][fault_id]

    # Connectivity faults
    if components.get("usb"):
        if "USB_NOT_RECOGNIZED" in faults_data["faults"]:
            applicable_faults["USB_NOT_RECOGNIZED"] = faults_data["faults"][
                "USB_NOT_RECOGNIZED"
            ]

    if components.get("midi_din"):
        if "MIDI_NOT_RECOGNIZED" in faults_data["faults"]:
            applicable_faults["MIDI_NOT_RECOGNIZED"] = faults_data["faults"][
                "MIDI_NOT_RECOGNIZED"
            ]

    # Aftertouch
    if components.get("aftertouch"):
        if "AFTERTOUCH_BROKEN" in faults_data["faults"]:
            applicable_faults["AFTERTOUCH_BROKEN"] = faults_data["faults"][
                "AFTERTOUCH_BROKEN"
            ]

    return list(applicable_faults.values())


@router.post("/calculate")
async def calculate_diagnostic(diagnostic: dict, settings: Settings = Depends(get_settings)):
    """
    Calculate diagnostic quote based on instrument and faults

    The quote calculation follows these rules:
    1. If POWER fault is present, it takes precedence over all others
    2. Base price is sum of all fault prices
    3. Applied multipliers:
       - Instrument tier (brand tier complexity factor)
       - Equipment value (estimated value multiplier)
    """

    # Find the instrument
    instrument = None
    for inst in instruments_data["instruments"]:
        if inst["id"] == diagnostic.get("equipment", {}).get("model"):
            instrument = inst
            break

    if not instrument:
        raise HTTPException(status_code=404, detail="Instrument not found")

    # Find the brand
    brand = None
    for b in brands_data["brands"]:
        if b["id"] == diagnostic.get("equipment", {}).get("brand"):
            brand = b
            break

    if not brand:
        raise HTTPException(status_code=404, detail="Brand not found")

    # Check for precedence faults (POWER)
    effective_faults = diagnostic.get("faults", [])
    if "POWER" in effective_faults:
        effective_faults = ["POWER"]

    # Calculate base cost
    base_cost = 0
    for fault_id in effective_faults:
        if fault_id in faults_data["faults"]:
            fault = faults_data["faults"][fault_id]
            base_cost += fault.get("basePrice", 0)

    # Get complexity factor from settings
    complexity_factor = settings.service_multipliers.get(brand.get("tier"), 1.0)


----- FILE: backend/app/routers/instrument.py -----
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from backend.app.models.instrument import Instrument
from backend.app.core.database import get_db

router = APIRouter(prefix="/api/instruments", tags=["Instruments"])

@router.get("/")
def list_instruments(db: Session = Depends(get_db)):
    return db.query(Instrument).all()

@router.post("/")
def create_instrument(payload: dict, db: Session = Depends(get_db)):
    db_inst = Instrument(**payload)
    db.add(db_inst)
    db.commit()
    db.refresh(db_inst)
    return db_inst

@router.put("/{instrument_id}")
def update_instrument(instrument_id: int, payload: dict, db: Session = Depends(get_db)):
    db_inst = db.query(Instrument).get(instrument_id)
    if not db_inst:
        raise HTTPException(status_code=404, detail="Instrument not found")
    for k, v in payload.items():
        setattr(db_inst, k, v)
    db.commit()
    db.refresh(db_inst)
    return db_inst

@router.delete("/{instrument_id}")
def delete_instrument(instrument_id: int, db: Session = Depends(get_db)):
    db_inst = db.query(Instrument).get(instrument_id)
    if not db_inst:
        raise HTTPException(status_code=404, detail="Instrument not found")
    db.delete(db_inst)
    db.commit()
    return {"ok": True}

----- FILE: backend/app/routers/payments.py -----
from fastapi import APIRouter, Depends, HTTPException
from typing import Dict, List
from pydantic import ValidationError
from backend.app.core.database import get_db
from sqlalchemy.orm import Session
from backend.app.models.payment import Payment, PaymentStatus
from backend.app.services.logging_service import create_audit
from sqlalchemy.exc import IntegrityError
from backend.app.schemas import PaymentCreate, PaymentRead

router = APIRouter(prefix="/payments", tags=["payments"])


@router.post("/", response_model=PaymentRead)
def create_payment(payload: PaymentCreate, db: Session = Depends(get_db)):
    # Pydantic validation already ensures basic correctness
    data = payload.dict()

    # Idempotency: if transaction_id provided and a payment already exists, return it
    tx = data.get("transaction_id")
    if tx:
        # Be tolerant: there may be duplicates in older data or race conditions that created
        # more than one row. Use first() ordered by id so we consistently return the
        # earliest existing payment rather than raising MultipleResultsFound.
        # Prefer the most recent payment for this transaction id (highest id)
        existing = db.query(Payment).filter(Payment.transaction_id == tx).order_by(Payment.id.desc()).first()
        if existing:
            try:
                create_audit(event_type="payment.duplicate", user_id=existing.user_id, details={"payment_id": existing.id, "transaction_id": tx}, message="Duplicate payment request detected")
            except Exception:
                pass
            return existing

    payment = Payment(
        user_id=data.get("user_id"),
        repair_id=data.get("repair_id"),
        amount=data.get("amount"),
        payment_method=data.get("payment_method"),
        transaction_id=data.get("transaction_id"),
        status=PaymentStatus.SUCCESS if (data.get("status") or "").lower() == "success" else PaymentStatus.PENDING,
        notes=data.get("notes"),
    )
    db.add(payment)
    try:
        db.commit()
        db.refresh(payment)
    except IntegrityError:
        # Handle race: another request created the same transaction_id concurrently
        # Roll back and return the existing payment.
        db.rollback()
        existing = None
        if tx:
            existing = db.query(Payment).filter(Payment.transaction_id == tx).order_by(Payment.id.desc()).first()
        if existing:
            try:
                create_audit(event_type="payment.duplicate", user_id=existing.user_id, details={"payment_id": existing.id, "transaction_id": tx}, message="Duplicate payment request detected (race)")
            except Exception:
                pass
            return existing
        # If we couldn't find the existing row, re-raise so callers/tests notice
        raise

    # audit with richer details
    try:
        create_audit(event_type="payment.create", user_id=payment.user_id, details={"payment_id": payment.id, "repair_id": payment.repair_id, "amount": payment.amount, "method": payment.payment_method, "transaction_id": payment.transaction_id, "status": payment.status}, message="Payment created")
    except Exception:
        pass

    return payment


@router.get("/", response_model=List[PaymentRead])
def list_payments(repair_id: int = None, user_id: int = None, db: Session = Depends(get_db)):
    q = db.query(Payment)
    if repair_id:
        q = q.filter(Payment.repair_id == repair_id)
    if user_id:
        q = q.filter(Payment.user_id == user_id)
    results = q.all()
    try:
        create_audit(event_type="payment.list", details={"repair_id": repair_id, "user_id": user_id}, message="Payments listed")
    except Exception:
        pass
    return results


@router.get("/{payment_id}", response_model=PaymentRead)
def get_payment(payment_id: int, db: Session = Depends(get_db)):
    payment = db.query(Payment).filter(Payment.id == payment_id).one_or_none()
    if not payment:
        raise HTTPException(status_code=404, detail="Payment not found")
    try:
        create_audit(event_type="payment.get", details={"payment_id": payment_id}, message="Payment fetched")
    except Exception:
        pass
    return payment

----- FILE: backend/app/routers/repair.py -----
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from backend.app.models.repair import Repair
from typing import Dict
from backend.app.core.database import get_db
from backend.app.services.logging_service import create_audit

router = APIRouter(prefix="/repairs", tags=["Repairs"])

@router.get("/")
def list_repairs(db: Session = Depends(get_db)):
    return db.query(Repair).all()

@router.post("/")
def create_repair(repair: Dict, db: Session = Depends(get_db)):
    # Accept a flexible payload for now to avoid schema package conflicts
    db_repair = Repair(**repair)
    db.add(db_repair)
    db.commit()
    db.refresh(db_repair)
    # Audit: repair created
    try:
        # Keep audit payload minimal and defensive: avoid referencing optional attrs
        create_audit(event_type="repair.create", user_id=None, details={"repair_id": db_repair.id}, message="Repair created")
    except Exception:
        # Non-fatal: auditing should not break main flow
        pass
    return db_repair

@router.put("/{repair_id}")
def update_repair(repair_id: int, repair: Dict, db: Session = Depends(get_db)):
    db_repair = db.query(Repair).get(repair_id)
    if not db_repair:
        raise HTTPException(status_code=404, detail="Repair not found")
    for key, value in repair.items():
        setattr(db_repair, key, value)
    db.commit()
    db.refresh(db_repair)
    # Audit: repair updated
    try:
        create_audit(event_type="repair.update", user_id=None, details={"repair_id": db_repair.id}, message="Repair updated")
    except Exception:
        pass
    return db_repair

@router.delete("/{repair_id}")
def delete_repair(repair_id: int, db: Session = Depends(get_db)):
    db_repair = db.query(Repair).get(repair_id)
    if not db_repair:
        raise HTTPException(status_code=404, detail="Repair not found")
    db.delete(db_repair)
    db.commit()
    # Audit: repair deleted
    try:
        create_audit(event_type="repair.delete", user_id=None, details={"repair_id": repair_id}, message="Repair deleted")
    except Exception:
        pass
    return {"ok": True}

----- FILE: backend/app/routers/stock_movement.py -----
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from backend.app.models.stock_movement import StockMovement
from backend.app.core.database import get_db

router = APIRouter(prefix="/api/stock-movements", tags=["StockMovements"])

@router.get("/")
def list_movements(db: Session = Depends(get_db)):
    return db.query(StockMovement).all()

@router.post("/")
def create_movement(payload: dict, db: Session = Depends(get_db)):
    db_obj = StockMovement(**payload)
    db.add(db_obj)
    db.commit()
    db.refresh(db_obj)
    return db_obj

----- FILE: backend/app/routers/uploads.py -----
from fastapi import APIRouter, UploadFile, File, Depends, status, Request
from backend.app.utils.uploads import validate_image, save_upload
from backend.app.core.ratelimit import limiter
from backend.app.services.logging_service import create_audit

router = APIRouter(prefix="/uploads", tags=["uploads"])


@router.post("/images", status_code=status.HTTP_201_CREATED)
@limiter.limit("20/minute")  # limit image uploads to protect abuse
async def upload_image(request: Request, file: UploadFile = File(...)):
    """Upload an image with validation (size, type)."""
    await validate_image(file)
    path = await save_upload(file)
    # Audit upload
    try:
        ip = None
        if request.client:
            ip = request.client.host
        create_audit(event_type="upload.image", user_id=None, ip_address=ip, details={"path": path, "filename": file.filename}, message="Image uploaded")
    except Exception:
        pass
    return {"path": path, "filename": file.filename}

----- FILE: backend/app/routers/user.py -----
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from backend.app.models.user import User
from backend.app.schemas.user import UserCreate, UserRead, UserUpdate
from backend.app.core.database import get_db

router = APIRouter(prefix="/api/users", tags=["Users"])

@router.get("/", response_model=list[UserRead])
def list_users(db: Session = Depends(get_db)):
    return db.query(User).all()

@router.post("/", response_model=UserRead)
def create_user(user: UserCreate, db: Session = Depends(get_db)):
    db_user = User(**user.dict())
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user

@router.put("/{user_id}", response_model=UserRead)
def update_user(user_id: int, user: UserUpdate, db: Session = Depends(get_db)):
    db_user = db.query(User).get(user_id)
    if not db_user:
        raise HTTPException(status_code=404, detail="User not found")
    for key, value in user.dict(exclude_unset=True).items():
        setattr(db_user, key, value)
    db.commit()
    db.refresh(db_user)
    return db_user

@router.delete("/{user_id}")
def delete_user(user_id: int, db: Session = Depends(get_db)):
    db_user = db.query(User).get(user_id)
    if not db_user:
        raise HTTPException(status_code=404, detail="User not found")
    db.delete(db_user)
    db.commit()
    return {"ok": True}

----- FILE: backend/app/schemas/__init__.py -----
"""
Pydantic schemas for request/response validation
Define DTOs (Data Transfer Objects) for API endpoints
"""

from pydantic import BaseModel, EmailStr, Field, field_validator
from typing import List, Optional, Dict, ClassVar
from datetime import datetime


# ============= BRAND =============
class BrandBase(BaseModel):
    id: str
    name: str
    tier: str
    founded: int
    country: str
    description: str


class BrandRead(BrandBase):
    pass

    class Config:
        from_attributes = True


# ============= INSTRUMENT =============
class InstrumentBase(BaseModel):
    id: str
    brand_id: str
    model: str
    type: str
    year: int
    description: str
    components: Optional[Dict] = None
    valor_min: Optional[float] = None
    valor_max: Optional[float] = None
    fallas_comunes: Optional[List[str]] = None
    imagen_url: Optional[str] = None
    manual_url: Optional[str] = None


class InstrumentRead(InstrumentBase):
    created_at: datetime

    class Config:
        from_attributes = True


# ============= FAULT =============
class FaultBase(BaseModel):
    id: str
    name: str
    description: str
    base_price: float
    is_precedence: bool = False


class FaultRead(FaultBase):
    created_at: datetime

    class Config:
        from_attributes = True


# ============= DIAGNOSTIC =============
class DiagnosticCreate(BaseModel):
    client_name: str = Field(..., min_length=2, max_length=100)
    client_email: EmailStr
    client_phone: Optional[str] = None
    brand_id: str
    instrument_id: str
    faults_json: Dict[str, bool]
    estimated_cost: float
    notes: Optional[str] = None


class DiagnosticRead(BaseModel):
    id: int
    client_name: str
    client_email: str
    client_phone: Optional[str]
    brand_id: str
    instrument_id: str
    faults_json: Dict
    estimated_cost: float
    status: str
    notes: Optional[str]
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True


# ============= REPAIR =============
class RepairDetailRead(BaseModel):
    id: int
    repair_id: int
    fault_id: str
    description: Optional[str]
    parts_used: Optional[Dict]
    created_at: datetime

    class Config:
        from_attributes = True


class RepairCreate(BaseModel):
    diagnostic_id: Optional[int] = None
    instrument_id: str
    brand_id: str
    client_name: str
    client_email: str
    actual_cost: float
    hours_worked: Optional[float] = None
    notes: Optional[str] = None
    completed_at: Optional[datetime] = None


class RepairRead(BaseModel):
    id: int
    diagnostic_id: Optional[int]
    instrument_id: str
    brand_id: str
    client_name: str
    client_email: str
    actual_cost: float
    hours_worked: Optional[float]
    notes: Optional[str]
    completed_at: Optional[datetime]
    created_at: datetime
    details: List[RepairDetailRead] = []

    class Config:
        from_attributes = True


# ============= API RESPONSE =============
class APIResponse(BaseModel):
    """Standard API response wrapper"""
    success: bool
    message: str
    data: Optional[Dict] = None
    errors: Optional[List[str]] = None


class QuoteEstimate(BaseModel):
    """Cotización estimada"""
    base_cost: float
    complexity_factor: float
    value_factor: float
    final_cost: float
    brand_tier: str


# ============= PAYMENT =============
class PaymentCreate(BaseModel):
    repair_id: int
    amount: int = Field(..., gt=0)
    payment_method: str
    transaction_id: Optional[str] = None
    user_id: Optional[int] = None
    status: Optional[str] = None
    notes: Optional[str] = None

    ALLOWED_METHODS: ClassVar[set] = {"card", "cash", "transfer", "paypal"}

    @field_validator("payment_method")
    def check_method(cls, v: str):
        if v not in cls.ALLOWED_METHODS:
            raise ValueError(f"Unsupported payment method: {v}")
        return v


class PaymentRead(BaseModel):
    id: int
    user_id: Optional[int]
    repair_id: Optional[int]
    amount: int
    payment_method: str
    transaction_id: Optional[str]
    status: str
    notes: Optional[str]
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True


"""
Pydantic schemas para autenticación
"""
from pydantic import BaseModel, EmailStr, Field
from typing import Optional


class Token(BaseModel):
    """Respuesta de token"""
    access_token: str
    refresh_token: str
    token_type: str = "bearer"


class TokenData(BaseModel):
    """Datos decodificados del token"""
    user_id: int
    username: str
    email: str
    role: str


class LoginRequest(BaseModel):
    """Request de login"""
    email: EmailStr
    password: str = Field(..., min_length=6)


class RegisterRequest(BaseModel):
    """Request de registro"""
    email: EmailStr
    username: str = Field(..., min_length=3, max_length=100)
    full_name: str = Field(..., min_length=3)
    password: str = Field(..., min_length=8)
    phone: Optional[str] = None


class PasswordResetRequest(BaseModel):
    """Request para recuperar contraseña"""
    email: EmailStr


class PasswordResetConfirm(BaseModel):
    """Confirmación de reset de contraseña"""
    token: str
    new_password: str = Field(..., min_length=8)


class RefreshTokenRequest(BaseModel):
    """Request para refrescar token"""
    refresh_token: str

----- FILE: backend/app/schemas/category.py -----

----- FILE: backend/app/schemas/diagnostic.py -----

----- FILE: backend/app/schemas/inventory.py -----

----- FILE: backend/app/schemas/repair.py -----

----- FILE: backend/app/schemas/user.py -----
"""
Pydantic schemas para usuarios
"""
from pydantic import BaseModel, EmailStr, Field
from typing import Optional
from datetime import datetime


class UserCreate(BaseModel):
    """Schema para crear usuario"""
    email: EmailStr
    username: str = Field(..., min_length=3)
    full_name: str
    password: str = Field(..., min_length=8)
    phone: Optional[str] = None


class UserUpdate(BaseModel):
    """Schema para actualizar usuario"""
    full_name: Optional[str] = None
    phone: Optional[str] = None


class UserResponse(BaseModel):
    """Schema para respuesta de usuario (sin contraseña)"""
    id: int
    email: str
    username: str
    full_name: str
    phone: Optional[str]
    role: str
    is_active: bool
    created_at: datetime
    
    class Config:
        from_attributes = True


class UserDetailResponse(UserResponse):
    """Detalle completo del usuario"""
    updated_at: datetime

======== BACKEND LÓGICA (ÍNDICE) =================
backend/app/crud/__init__.py
backend/app/crud/base.py
backend/app/crud/category.py
backend/app/crud/inventory.py
backend/app/crud/repair.py
backend/app/crud/user.py
backend/app/models/__init__.py
backend/app/models/audit.py
backend/app/models/brand.py
backend/app/models/category.py
backend/app/models/diagnostic.py
backend/app/models/instrument.py
backend/app/models/inventory.py
backend/app/models/payment.py
backend/app/models/repair.py
backend/app/models/stock_movement.py
backend/app/models/user.py
backend/app/services/ai_detector.py
backend/app/services/email_service.py
backend/app/services/image_analysis.py
backend/app/services/logging_service.py
backend/app/services/pdf_generator.py
backend/app/services/quote_calculator.py

================ BACKEND TESTS ===================
backend/tests/__init__.py
backend/tests/conftest.py
backend/tests/test_audit_hooks.py
backend/tests/test_audit_logging.py
backend/tests/test_config.py
backend/tests/test_payments_concurrency.py
backend/tests/test_payments_endpoints.py
backend/tests/test_ratelimit.py
backend/tests/test_uploads.py

